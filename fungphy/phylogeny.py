"""Phylogenetic workflows."""


import datetime
import re
import subprocess
from pathlib import Path
from tempfile import NamedTemporaryFile as NTF


def parse_alignment(handle):
    header, body = "", ""
    records = []
    for line in handle:
        if line.startswith(">"):
            if header and body:
                sequence = Sequence(header, body)
                records.append(sequence)
                body = ""
            header = line.strip().replace(">", "")
        else:
            body += line.strip()

    sequence = Sequence(header, body)
    records.append(sequence)

    return records


def trim(msa, threshold=0.0):
    """Trim a MSA to its first and last non-gap containing columns."""

    def gap_pct(msa, index):
        return msa.column(index).count("-") / msa.count()

    length = len(msa)
    start, end = 0, length - 1
    start_found, end_found = False, False

    for i in range(length):
        if start_found and end_found:
            break

        if not start_found and gap_pct(msa, i) > threshold:
            start += 1
        else:
            start_found = True

        # Since we just decrement end, can use it as the index
        if not end_found and gap_pct(msa, end) > threshold:
            end -= 1
        else:
            end_found = True

    return msa[start:end]


class MultiMSA:
    """Represents a multi-locus MSA.

    Keep MSA objects separate and dynamically generate partition information.

    Headers in each MSA must be identical.
    """

    def __init__(self, msas=None):
        self.msas = []
        self.partitions = []
        if msas:
            for msa in msas:
                self.add(msa)

    def __iter__(self):
        return iter(self.msas)

    def __getitem__(self, value):
        if isinstance(value, slice):
            return MultiMSA(self.msas[value.start : value.stop])
        else:
            return self.msas[value]

    def __len__(self):
        return sum(len(msa) for msa in self)

    @property
    def headers(self):
        return self.msas[0].headers

    def compute_partitions(self):
        start, end = 1, len(self[0])
        self.partitions = [(start, end)]
        for msa in self[1:]:
            end = self.partitions[-1][1]
            position = (end + 1, end + len(msa))
            self.partitions.append(position)

    def __add__(self, other):
        if not self.headers_match(other):
            raise ValueError("Headers do not match")
        return MultiMSA(self.msas + other.msas)

    def headers_match(self, other):
        if not isinstance(other, MultiMSA):
            raise TypeError("Expected MultiMSA object")
        return set(self.headers) == set(other.headers)

    def add(self, new):
        if not isinstance(new, MSA):
            raise ValueError("Expected MSA object")
        for msa in self:
            if set(msa.headers) != set(new.headers):
                raise ValueError(f"Header mismatch: {msa.name} vs {new.name}")
        self.msas.append(new)
        self.compute_partitions()

    def iter_partitions(self):
        for msa_name, (start, end) in zip(self, self.partitions):
            yield msa_name, (start, end)

    def raxml_partitions(self):
        return "\n".join(
            f"DNA, {msa.name} = {start}-{end}"
            for msa, (start, end) in self.iter_partitions()
        )

    def fasta(self):
        return "\n".join(
            f">{header}\n{''.join(msa[header].sequence for msa in self)}"
            for header in self.headers
        )

    @classmethod
    def from_fasta_files(cls, files, tool="mafft", trim_msa=True):
        msas = []
        for fasta in files:
            m = align(fasta, tool=tool, name=Path(fasta).stem)
            if trim_msa:
                m = trim(m)
            msas.append(m)
        return cls(msas)

    @classmethod
    def from_msa_file(cls, msa_file, partition_file):
        """Read in multilocus MSA file, split by partition.

        msa_file should be MSA in FASTA format, partition_file should be in
        RAXML format, as generated by MultiMSA.raxml_partitions()
        """
        with open(msa_file) as fp:
            raw = MSA.from_file(fp)
        pattern = re.compile(r"DNA, (.+?) = (\d+)-(\d+)")
        msas = []
        with open(partition_file) as fp:
            for row in fp:
                name, start, end = pattern.search(row).groups()
                m = raw[int(start) - 1 : int(end)]
                m.name = name
                msas.append(m)
        return cls(msas)


class MSA:
    """Represents a multiple sequence alignment."""

    def __init__(self, name=None, records=None):
        self.name = name
        self.records = list(records) if records else []

    def __iter__(self):
        return iter(self.records)

    def __len__(self):
        return len(self.records[0].sequence)

    def __getitem__(self, value):
        if isinstance(value, slice):
            sliced = [record[value.start : value.stop] for record in self]
            return MSA(name=self.name, records=sliced)
        elif isinstance(value, str):
            for rec in self:
                if rec.header == value:
                    return rec
            raise KeyError(f"No record with header: {value}")
        else:
            return self.records[value]

    def __add__(self, other):
        if not isinstance(other, MSA):
            raise TypeError("Expected MSA object")
        return MultiMSA(records=[self, other])

    @property
    def headers(self):
        return [r.header for r in self]

    def count(self):
        return len(self.records)

    def column(self, index):
        return [r.sequence[index] for r in self]

    def fasta(self):
        return "\n".join(r.fasta() for r in self)

    def phylip(self):
        header = f"{len(self.records)} {len(self)}"
        body = "\n".join(f"{r.header}\t{r.sequence}" for r in self)
        return f"{header}\n{body}"

    @classmethod
    def from_file(cls, fp, name=None):
        return cls(records=parse_alignment(fp), name=name)


class Sequence:
    """Represents a sequence in a FASTA file."""

    def __init__(self, header, sequence):
        self.header = header
        self.sequence = sequence

    def __getitem__(self, value):
        if isinstance(value, slice):
            return Sequence(self.header, self.sequence[value.start : value.stop])
        else:
            return self.sequence[value]

    def fasta(self):
        return f">{self.header}\n{self.sequence}"


def align_sequences(sequences, name=None, tool="mafft", cpu=2, trim_msa=False):
    """Align Sequence objects."""

    with NTF("w") as fna:
        fasta = "\n".join(s.fasta() for s in sequences)
        fna.write(fasta)
        fna.seek(0)
        msa = align(fna.name, tool=tool, name=name, cpu=cpu)

    if trim_msa:
        msa = trim(msa)

    return msa


def align(fasta, tool="mafft", name=None, cpu=2):
    """Align FASTA file with MAFFT."""
    if tool == "mafft":
        cmd = ["linsi", "--quiet", "--thread", str(cpu), fasta]
    elif tool == "muscle":
        cmd = ["muscle", "-in", fasta, "-quiet"]
    process = subprocess.run(cmd, stdout=subprocess.PIPE)
    return MSA.from_file(process.stdout.decode().split("\n"), name=name)


def iqtree(msa):
    """Generate tree from MSA using IQ-Tree."""
    # TODO: "-B", "1000", "--alrt", "1000",
    cmd = ["iqtree", "-s", msa, "-nt", "AUTO", "--quiet"]
    tree = subprocess.run(cmd, stdout=subprocess.PIPE)
    return tree.stdout.decode()


def make(markers, folder=None):
    """Run the workflow"""

    # Pre: Set up directory
    today = datetime.datetime.now().strftime("%Y_%b_%d_%M%S")
    print(f"Making directory:\n  {today}")
    folder = Path(today)
    folder.mkdir()

    # 1. select marker sequences from db
    print("Retrieving markers from DB")
    organisms = query(markers)

    # 2. make named temp file fasta
    for marker in markers:
        fasta_file = folder / f"{marker}.fna"

        print(f"Forming '{marker}' FASTA file:\n  {fasta_file}")
        with fasta_file.open("w") as fp:
            for organism in organisms.values():
                fp.write(organism[marker] + "\n")

        print("Aligning with MAFFT")
        msa = align(fasta_file)
        pre = len(msa)
        msa = trim(msa)
        msa_file = folder / f"{marker}.msa"

        print(f"Trimmed MSA from {pre} to {len(msa)} columns")
        print(f"Writing:\n  {msa_file}")
        with (folder / f"{marker}.msa").open("w") as fp:
            fp.write(msa.fasta())

        print("Generating gene tree with IQ-Tree:")
        print(f"  report: {msa_file}.iqtree")
        print(f"    tree: {msa_file}.treefile")
        print(f"     log: {msa_file}.log")
        tree(msa_file)

    # TODO: reconcile gene trees with ASTRAL-III
    #       or do partition analyses with IQ-Tree


def fasttree(msa, **kwargs):
    """Run FastTree on an MSA."""

    cmd = ["FastTree", "-quiet", "-nt"]

    for key, value in kwargs.items():
        # Check if argument is a boolean flag
        if value is True:
            cmd.append(f"-{key}")
        else:
            cmd.extend([f"-{key}", value])

    process = subprocess.run(cmd, text=True, input=msa.fasta(), capture_output=True)

    return process.stdout.strip()



def astral(trees):
    """Reconcile gene trees to form unrooted species tree with ASTRAL."""
    pass
