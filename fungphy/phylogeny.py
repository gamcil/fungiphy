"""Phylogenetic workflows."""

from __future__ import annotations

import datetime
import re
import subprocess
from pathlib import Path
from tempfile import NamedTemporaryFile as NTF
from typing import TextIO, List


def parse_alignment(handle: TextIO) -> List[Sequence]:
    header, body = "", ""
    records = []
    for line in handle:
        if line.startswith(">"):
            if header and body:
                sequence = Sequence(header, body)
                records.append(sequence)
                body = ""
            header = line.strip().replace(">", "")
        else:
            body += line.strip()

    sequence = Sequence(header, body)
    records.append(sequence)

    return records


def trim(msa, threshold=0.0):
    """Trim a MSA to its first and last non-gap containing columns."""

    def gap_pct(msa, index):
        return msa.column(index).count("-") / msa.count()

    length = len(msa)
    start, end = 0, length - 1
    start_found, end_found = False, False

    for i in range(length):
        if start_found and end_found:
            break

        if not start_found and gap_pct(msa, i) > threshold:
            start += 1
        else:
            start_found = True

        # Since we just decrement end, can use it as the index
        if not end_found and gap_pct(msa, end) > threshold:
            end -= 1
        else:
            end_found = True

    return msa[start:end]


class MultiMSA:
    """Represents a multi-locus MSA.

    Keep MSA objects separate and dynamically generate partition information.

    Headers in each MSA must be identical.
    """

    def __init__(self, msas=None):
        self.msas = []
        self.partitions = []
        if msas:
            for msa in msas:
                self.add(msa)

    def __iter__(self):
        return iter(self.msas)

    def __getitem__(self, value):
        if isinstance(value, slice):
            return MultiMSA(self.msas[value.start : value.stop])
        else:
            return self.msas[value]

    def __len__(self):
        return sum(len(msa) for msa in self)

    @property
    def headers(self):
        return self.msas[0].headers

    def compute_partitions(self):
        start, end = 1, len(self[0])
        self.partitions = [(start, end)]
        for msa in self[1:]:
            end = self.partitions[-1][1]
            position = (end + 1, end + len(msa))
            self.partitions.append(position)

    def __add__(self, other):
        if self.msas and not self.headers_match(other):
            raise ValueError("Headers do not match")
        return MultiMSA(self.msas + other.msas)

    def headers_match(self, other):
        if not isinstance(other, MultiMSA):
            raise TypeError("Expected MultiMSA object")
        return set(self.headers) == set(other.headers)

    def add(self, new):
        if not isinstance(new, MSA):
            raise ValueError("Expected MSA object")
        for msa in self:
            if set(msa.headers) != set(new.headers):
                raise ValueError(f"Header mismatch: {msa.name} vs {new.name}")
        self.msas.append(new)
        self.compute_partitions()

    def iter_partitions(self):
        for msa_name, (start, end) in zip(self, self.partitions):
            yield msa_name, (start, end)

    def raxml_partitions(self):
        return "\n".join(
            f"DNA, {msa.name} = {start}-{end}"
            for msa, (start, end) in self.iter_partitions()
        )

    def fasta(self):
        return "\n".join(
            f">{header}\n{''.join(msa[header].sequence for msa in self)}"
            for header in self.headers
        )

    @classmethod
    def from_fasta_files(cls, files, names=None, tool="mafft", trim_msa=True,
                         align=False):
        if names and len(files) != len(names):
            raise ValueError("File list different size than name list")
        msas, size = [], len(files)
        for i in range(size):
            fasta = files[i]
            name = names[i] if names else Path(fasta).stem
            if align:
                m = align(fasta, tool=tool, name=name)
                if trim_msa:
                    m = trim(m)
            else:
                m = MSA.from_file_path(fasta, name=name)
            msas.append(m)
        return cls(msas)

    @classmethod
    def from_partitioned(cls, msa_file, partition_file):
        """Read in multilocus MSA file, split by partition.

        msa_file should be MSA in FASTA format, partition_file should be in
        RAXML format, as generated by MultiMSA.raxml_partitions()
        """
        with open(msa_file) as fp:
            raw = MSA.from_file(fp)
        pattern = re.compile(r"DNA, (.+?) = (\d+)-(\d+)")
        msas = []
        with open(partition_file) as fp:
            for row in fp:
                name, start, end = pattern.search(row).groups()
                m = raw[int(start) - 1 : int(end)]
                m.name = name
                msas.append(m)
        return cls(msas)


class MSA:
    """Represents a multiple sequence alignment."""

    def __init__(self, name=None, records=None):
        self.name = name
        self.records = list(records) if records else []

    def __iter__(self):
        return iter(self.records)

    def __len__(self):
        return len(self.records[0].sequence)

    def __getitem__(self, value):
        if isinstance(value, slice):
            sliced = [record[value.start : value.stop] for record in self]
            return MSA(name=self.name, records=sliced)
        elif isinstance(value, str):
            for rec in self:
                if rec.header == value:
                    return rec
            raise KeyError(f"No record with header: {value}")
        else:
            return self.records[value]

    def __add__(self, other):
        if not isinstance(other, MSA):
            raise TypeError("Expected MSA object")
        return MultiMSA(records=[self, other])

    @property
    def headers(self):
        return [r.header for r in self]

    def count(self):
        return len(self.records)

    def column(self, index):
        return [r.sequence[index] for r in self]

    def fasta(self):
        return "\n".join(r.fasta() for r in self)

    def phylip(self):
        header = f"{len(self.records)} {len(self)}"
        body = "\n".join(f"{r.header}\t{r.sequence}" for r in self)
        return f"{header}\n{body}"

    @classmethod
    def from_file(cls, fp, name=None):
        return cls(records=parse_alignment(fp), name=name)

    @classmethod
    def from_file_path(cls, path, name=None):
        with open(path) as fp:
            msa = cls.from_file(fp, name=name)
        return msa


class Sequence:
    """Represents a sequence in a FASTA file."""

    def __init__(self, header, sequence):
        self.header = header
        self.sequence = sequence

    def __str__(self):
        return self.fasta()

    def __getitem__(self, value):
        if isinstance(value, slice):
            return Sequence(self.header, self.sequence[value.start : value.stop])
        else:
            return self.sequence[value]

    def fasta(self):
        return f">{self.header}\n{self.sequence}"

    @staticmethod
    def from_fasta(fasta: str) -> Sequence:
        with open(fasta) as fp:
            return parse_alignment(fp)[0]


def align_sequences(sequences, name=None, tool="mafft", cpu=2, trim_msa=False):
    """Align Sequence objects."""

    with NTF("w") as fna:
        fasta = "\n".join(s.fasta() for s in sequences)
        fna.write(fasta)
        fna.seek(0)
        msa = align(fna.name, tool=tool, name=name, cpu=cpu)

    if trim_msa:
        msa = trim(msa)

    return msa


def align(fasta, tool="mafft", name=None, cpu=2):
    """Align FASTA file with MAFFT."""
    if tool == "linsi":
        cmd = ["linsi", "--quiet", "--thread", str(cpu), fasta]
    elif tool == "mafft":
        cmd = ["mafft", "--quiet", "--auto", "--thread", str(cpu), fasta]
    elif tool == "muscle":
        cmd = ["muscle", "-in", fasta, "-quiet"]
    else:
        raise ValueError("Expected 'mafft' or 'muscle'")
    process = subprocess.run(cmd, stdout=subprocess.PIPE)
    return MSA.from_file(process.stdout.decode().split("\n"), name=name)


def iqtree(msa):
    """Generate tree from MSA using IQ-Tree."""
    # TODO: "-B", "1000", "--alrt", "1000",
    cmd = ["iqtree", "-s", msa, "-nt", "AUTO", "--quiet"]
    tree = subprocess.run(cmd, stdout=subprocess.PIPE)
    return tree.stdout.decode()


def fasttree(msa, **kwargs):
    """Run FastTree on an MSA."""

    cmd = ["FastTree", "-quiet", "-nt"]

    for key, value in kwargs.items():
        # Check if argument is a boolean flag
        if value is True:
            cmd.append(f"-{key}")
        elif value is False:
            pass
        else:
            cmd.extend([f"-{key}", value])

    process = subprocess.run(cmd, text=True, input=msa.fasta(), capture_output=True)

    return process.stdout.strip()
